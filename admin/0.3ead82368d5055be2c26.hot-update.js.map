{"version":3,"file":"0.3ead82368d5055be2c26.hot-update.js","sources":["webpack:///./src/components/MainLayoutProvider/MainLayoutProvider.js"],"sourcesContent":["import React, { Component } from \"react\";\nimport { Location } from \"@reach/router\";\nimport debounce from \"lodash/debounce\";\nimport throttle from \"lodash/throttle\";\n\nimport { backgrounds } from \"../../components/MainPageElements/Background\";\nimport { ImagesDownloadListener } from \"../../components/ImagesDownloadListener/ImagesDownloadListener\";\nimport { Swiper } from \"../../components/Swiper/Swiper\";\nimport { mobileMenu as mobileMenuWidth } from \"../../components/Navbar/styles\";\nimport { navigateTo, getRouteByLocation, getRouteById } from \"../../routes/utils\";\nimport styles, { ScrollBar } from \"./styles\";\n\nimport \"../ScrollbarProvider/plugins/disableScrollByDirection\";\n\nconst ScrollContext = React.createContext();\n\nexport class MainLayoutProviderComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.onResize = debounce(this.onResize, 200);\n    this.checkBlockIsCenter = throttle(this.checkBlockIsCenter, 100);\n    this.checkNavbarIntoContent = throttle(this.checkNavbarIntoContent, 100);\n    this.scrollToBlock = debounce(this.scrollToBlock, 100);\n    this.onNavigateToThrottled = throttle(this.onNavigateTo, 400, {\n      leading: true,\n      trailing: false,\n    });\n\n    const { location, routes } = props;\n    const currentRoute = getRouteByLocation(location, routes);\n    const id = currentRoute && currentRoute.id;\n    const sections = (currentRoute && currentRoute.sections) || [];\n\n    const idFromLocalstorage = typeof window === \"object\" && localStorage.getItem(id);\n    const selectedSectionIndexFromStorage =\n      idFromLocalstorage && sections\n        ? sections.findIndex(section => section.id === idFromLocalstorage)\n        : 0;\n\n    if (typeof window === \"object\") {\n      localStorage.removeItem(id);\n    }\n\n    this.state = {\n      scrollTop: 0,\n      limitY: 0,\n      coloredNav: false,\n      currentRoute: null,\n      direction: 1,\n      transitionEnd: true,\n      mobileMenuIsOpen: false,\n      damping: 0.1,\n      thresholdIsActive: false,\n      scrollEvent: false,\n\n      // sections\n      selectedSectionIndex: selectedSectionIndexFromStorage,\n      sections: (currentRoute && currentRoute.sections) || [],\n      sectionDirection: 1,\n      lastSectionIndex: 0,\n      disableBackgroundTransition: false,\n    };\n  }\n\n  defaultDamping = 0.1;\n  threshold = 0;\n  scrollbar = null;\n  scrollable = null;\n  lefsideSection = null;\n  disableSwipeNavigation = false;\n\n  componentDidMount() {\n    this.setCurrentRoute();\n    window.addEventListener(\"resize\", this.onResize);\n    window.addEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.onResize);\n    window.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  componentDidUpdate({ location: prevLocation }) {\n    const { location } = this.props;\n\n    if (prevLocation.pathname !== location.pathname) {\n      this.setCurrentRoute();\n    }\n  }\n\n  onKeyDown = () => {\n    const { damping } = this.state;\n\n    if (damping !== this.defaultDamping) {\n      this.setState({\n        damping: this.defaultDamping,\n      });\n    }\n  };\n\n  getSize = () => {\n    return {\n      width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),\n      height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0),\n    };\n  };\n\n  onResize = () => {\n    const { width } = this.getSize();\n\n    if (width > mobileMenuWidth) {\n      this.setState({ mobileMenuIsOpen: false });\n    }\n  };\n\n  setCurrentRoute = () => {\n    const { location, routes } = this.props;\n    const { selectedSectionIndex, scrollEvent, direction } = this.state;\n    const currentRoute = getRouteByLocation(location, routes);\n    const { state } = location;\n    const sections = (currentRoute && currentRoute.sections) || [];\n    this.setState(\n      {\n        currentRoute: currentRoute || \"404\",\n        coloredNav: false,\n        sections,\n      },\n      () => {\n        const margin = 30;\n\n        if (state && state.scrollTo && this.scrollbar) {\n          const index = sections.findIndex(section => section.id === state.scrollTo);\n          let offsetTop = 0;\n\n          if (this.lefsideSection) {\n            const { top } = this.lefsideSection.getBoundingClientRect();\n            offsetTop = top + margin / 2;\n          }\n\n          this.scrollToBlock({\n            index,\n            offsetTop,\n            damping: 0.4,\n          });\n        } else if (currentRoute && currentRoute.scrollable) {\n          const scrollToEndBlock =\n            scrollEvent && selectedSectionIndex === (currentRoute && sections.length - 1);\n\n          let timetout = this.scrollable ? 0 : 44;\n\n          setTimeout(() => {\n            const { height: vh } = this.getSize();\n\n            let offsetTop = 0;\n            if (this.lefsideSection) {\n              const { height, top } = this.lefsideSection.getBoundingClientRect();\n\n              if (direction < 0) {\n                offsetTop = top - 80 - margin * 2;\n              } else {\n                offsetTop = vh / 2 + height / 2 - margin * 2;\n              }\n            }\n\n            if (\n              scrollToEndBlock &&\n              this.scrollable &&\n              this.scrollable.children[selectedSectionIndex]\n            ) {\n              const { height: rightBlockHeight } = this.scrollable.children[\n                selectedSectionIndex\n              ].getBoundingClientRect();\n              offsetTop -= rightBlockHeight + vh * 0.3;\n            }\n\n            this.scrollToBlock({\n              index: selectedSectionIndex,\n              damping: scrollEvent ? 1 : 0.2,\n              offsetTop,\n            });\n          }, timetout);\n        }\n      },\n    );\n  };\n\n  checkNavbarIntoContent = () => {\n    const { currentRoute } = this.state;\n\n    if (this.scrollable && this.scrollable.children[0]) {\n      const headerHeight = 80;\n      const { top } = this.scrollable.children[0].getBoundingClientRect();\n\n      const scrollable = currentRoute && currentRoute.scrollable;\n      if (top <= headerHeight && scrollable) {\n        this.setState({\n          coloredNav: true,\n        });\n      } else {\n        this.setState({\n          coloredNav: false,\n        });\n      }\n    }\n  };\n\n  getIndexFromDirection = (currentRoute, direction) => {\n    if (!currentRoute) return 0;\n\n    const { sections, maxItemCount } = currentRoute;\n\n    const sectionsLength = maxItemCount || (sections && sections.length) || 1;\n    const indexFromDirection = direction < 0 ? sectionsLength - 1 : 0;\n\n    return indexFromDirection;\n  };\n\n  checkBlockIsCenter = (direction, divider = 2) => {\n    const { selectedSectionIndex, currentRoute } = this.state;\n    const value = selectedSectionIndex + direction;\n    const currentBlock = this.scrollable && this.scrollable.children[value];\n\n    if (currentBlock && currentRoute && currentRoute.scrollable) {\n      const { height } = this.getSize();\n\n      const { top, bottom } = currentBlock.getBoundingClientRect();\n      const isTop = top < height / divider;\n      const isBottom = bottom > height / divider;\n      if (isTop && direction > 0) {\n        this.onSectionChange({ value: 1 });\n      } else if (isBottom && direction < 0) {\n        this.onSectionChange({ value: -1 });\n      }\n    }\n  };\n\n  onScroll = e => {\n    this.scrollbar.scrollLeft = 0;\n    const { scrollTop } = this.state;\n    const { offset, limit } = e;\n    const { y: offsetY } = offset;\n    const { y: limitY } = limit;\n\n    this.setState(\n      {\n        scrollTop: offsetY,\n        limitY,\n        thresholdIsActive: offsetY >= limitY || offsetY === 0,\n      },\n      () => {\n        const direction = offsetY > scrollTop ? 1 : -1;\n\n        this.checkBlockIsCenter(direction);\n        this.checkNavbarIntoContent();\n        if (offsetY >= limitY || offsetY === 0) {\n          this.threshold = 0;\n        }\n      },\n    );\n  };\n\n  onWheel = e => {\n    const { thresholdIsActive, scrollTop } = this.state;\n    const { location, navigate } = this.props;\n    const direction = e.deltaY > 0 ? 1 : -1;\n    const normalizeDeltaY = direction > 0 ? 53 : -53;\n    const is404Page = location.pathname.indexOf(\"404\") === 1;\n    if (thresholdIsActive || (scrollTop === 0 && direction < 0)) {\n      this.threshold = this.threshold + normalizeDeltaY;\n    }\n\n    this.setState({ direction, damping: this.defaultDamping, scrollEvent: true });\n\n    this.checkNavbarIntoContent();\n\n    if (is404Page) {\n      navigate(\"/\");\n    } else {\n      this.onNavigateToThrottled(direction);\n    }\n  };\n\n  onExited = () => {\n    this.setState({\n      transitionEnd: true,\n      coloredNav: false,\n      limitY: 0,\n      lastSectionIndex: 0,\n    });\n  };\n\n  onNavLinkClick = ({ id, event, navigate, selectedSectionIndex, transitionEnd }) => {\n    const { routes } = this.props;\n    const { currentRoute } = this.state;\n\n    const prevIndex = routes.findIndex(route => route.id === currentRoute.id);\n    const currentIndex = routes.findIndex(route => route.id === id);\n    const direction = currentIndex > prevIndex ? 1 : -1;\n\n    if (currentRoute && currentRoute.id === id) {\n      event && event.preventDefault();\n      return;\n    }\n\n    const nextPage = routes[currentIndex];\n    const prevPageId = currentRoute ? currentRoute.id : \"\";\n    const nextPageId = nextPage ? nextPage.id : \"\";\n\n    const disableBackgroundTransition =\n      (prevPageId === \"portfolio\" && nextPageId === \"about\") ||\n      (prevPageId === \"about\" && nextPageId === \"portfolio\");\n\n    this.setState(\n      {\n        scrollEvent: false,\n        selectedSectionIndex: selectedSectionIndex || 0,\n        direction,\n        mobileMenuIsOpen: false,\n        disableBackgroundTransition,\n        transitionEnd,\n      },\n      () => {\n        if (navigate && nextPage) {\n          navigate(nextPage.route);\n        }\n      },\n    );\n  };\n\n  onScrollableRef = ref => {\n    if (ref) {\n      this.scrollable = ref;\n    }\n  };\n\n  onScrollBarRef = ref => {\n    if (ref) {\n      this.scrollbar = ref.scrollbar;\n    }\n  };\n\n  onLeftSideSectionRef = ref => {\n    if (ref) {\n      this.lefsideSection = ref;\n    }\n  };\n\n  toggleMobileMenu = () =>\n    this.setState(({ mobileMenuIsOpen }) => ({\n      mobileMenuIsOpen: !mobileMenuIsOpen,\n    }));\n\n  scrollToBlock = ({ index, damping = 0.2, offsetTop = 0 }) => {\n    if (this.scrollbar && this.scrollable && this.scrollable.children[index]) {\n      this.setState(\n        {\n          damping,\n        },\n        () => {\n          this.scrollbar.scrollIntoView(this.scrollable.children[index], {\n            offsetTop,\n            onlyScrollIfNeeded: false,\n          });\n        },\n      );\n    }\n  };\n\n  onSectionChange = ({ value, id, pageId, index = null, scrollToBlock = false }) => {\n    const { navigate, routes } = this.props;\n    const { selectedSectionIndex, sections, currentRoute } = this.state;\n\n    const pageIsChanged = pageId && currentRoute && currentRoute.id !== pageId;\n    const sectionsLength =\n      (currentRoute && currentRoute.maxItemCount) || (sections && sections.length) || 1;\n\n    const nextValue = id\n      ? sections.findIndex(item => item.id === id)\n      : index !== null\n      ? index\n      : selectedSectionIndex + value;\n\n    if (pageIsChanged) {\n      const { sections } = getRouteById(pageId, routes);\n      const index = sections.findIndex(item => item.id === id);\n\n      this.onNavLinkClick({\n        selectedSectionIndex: index,\n        id: pageId,\n        navigate,\n        disableBackgroundTransition: false,\n      });\n    } else {\n      if (nextValue >= sectionsLength || nextValue < 0) return;\n\n      const sectionDirection = selectedSectionIndex > nextValue ? -1 : 1;\n\n      if (currentRoute.scrollable && scrollToBlock) {\n        const margin = 30;\n        this.scrollToBlock({\n          index: nextValue,\n          offsetTop: this.lefsideSection ? this.lefsideSection.offsetTop + margin / 2 : 0,\n        });\n      }\n\n      this.setState({\n        scrollEvent: false,\n        sectionDirection,\n        selectedSectionIndex: nextValue,\n        disableBackgroundTransition: false,\n      });\n    }\n  };\n\n  onSwiped = () => {\n    this.disableSwipeNavigation = false;\n  };\n\n  onSwiping = ({ isUp, isDown, yRatio }) => {\n    const { damping, sections, selectedSectionIndex, currentRoute, scrollEvent } = this.state;\n    const { location, navigate } = this.props;\n    const is404Page = location.pathname.indexOf(\"404\") === 1;\n    const sectionsLength = (currentRoute && currentRoute.maxItemCount) || sections.length;\n    const scrollable = currentRoute && currentRoute.scrollable;\n\n    const page = sectionsLength === 0 && !scrollable;\n    const goUp = isUp && yRatio > 25;\n    const goDown = isDown && yRatio > 25;\n    const goPrevSection = goDown && selectedSectionIndex - 1 >= 0;\n    const goNextSection = goUp && selectedSectionIndex + 1 <= sectionsLength;\n    const goPrevPage = goDown && (selectedSectionIndex === 0 || page);\n    const goNextPage = goUp && (selectedSectionIndex + 1 === sectionsLength || page);\n\n    if (!scrollEvent) {\n      this.setState({ scrollEvent: true });\n    }\n\n    if (is404Page) {\n      navigate(\"/\");\n    } else if ((goPrevPage || goNextPage) && !this.disableSwipeNavigation) {\n      this.onNavigateTo(goNextPage ? 1 : -1, true);\n      this.disableSwipeNavigation = true;\n    } else if ((goPrevSection || goNextSection) && !this.disableSwipeNavigation && !scrollable) {\n      this.setState({\n        sectionDirection: goNextSection ? 1 : -1,\n        selectedSectionIndex: selectedSectionIndex + (goNextSection ? 1 : -1),\n        disableBackgroundTransition: false,\n      });\n      this.disableSwipeNavigation = true;\n    }\n\n    if (damping !== this.defaultDamping) {\n      this.setState({\n        damping: this.defaultDamping,\n      });\n    }\n  };\n\n  onEnter = () => {\n    if (this.scrollbar) {\n      this.scrollbar.scrollLeft = 0;\n      this.scrollbar.scrollTop = 0;\n    }\n    this.setState({ transitionEnd: false });\n  };\n\n  onNavigateTo = (direction, routeSwipeUpAndDown = false) => {\n    const { height } = this.getSize();\n\n    const {\n      currentRoute,\n      scrollTop,\n      limitY,\n      selectedSectionIndex,\n      sections,\n      transitionEnd,\n    } = this.state;\n    const { navigate, location, routes } = this.props;\n    const { pathname } = location;\n\n    if (!currentRoute) {\n      return;\n    }\n\n    const scrollable = currentRoute && currentRoute.scrollable;\n    const ratio = height / 4.8;\n    const scrollableToTop =\n      scrollable &&\n      (Math.abs(this.threshold) > ratio || routeSwipeUpAndDown) &&\n      direction < 0 &&\n      scrollTop === 0;\n\n    const scrollToBottom =\n      scrollable && direction > 0 && limitY && scrollTop && scrollTop + 144 >= limitY;\n\n    if ((!scrollable || scrollableToTop || scrollToBottom) && transitionEnd) {\n      const slider = currentRoute && currentRoute.slider;\n      const isPortfolioPage = currentRoute && currentRoute.id === \"portfolio\";\n      const up = selectedSectionIndex === 0 && direction < 0;\n      const nextIndex = selectedSectionIndex + direction;\n      const sectionsLength = currentRoute.maxItemCount || sections.length;\n      const down = nextIndex === sectionsLength;\n\n      if (slider && !up && !down && !routeSwipeUpAndDown) {\n        // section change\n        const sectionDirection = selectedSectionIndex > nextIndex ? -1 : 1;\n        this.setState({\n          disableBackgroundTransition: false,\n          transitionEnd: !isPortfolioPage,\n          sectionDirection,\n          selectedSectionIndex: nextIndex,\n        });\n      } else {\n        // page change\n        const nextPage = navigateTo({ navigate, pathname, direction, routes });\n        const prevPageId = currentRoute ? currentRoute.id : \"\";\n        const nextPageId = nextPage ? nextPage.id : \"\";\n\n        const disableBackgroundTransition =\n          (prevPageId === \"portfolio\" && nextPageId === \"about\") ||\n          (prevPageId === \"about\" && nextPageId === \"portfolio\");\n\n        const selectedSectionIndexFromIndex = this.getIndexFromDirection(nextPage, direction);\n\n        if (nextPage) {\n          this.setState({\n            transitionEnd: false,\n            selectedSectionIndex: selectedSectionIndexFromIndex,\n            lastSectionIndex: selectedSectionIndex,\n            direction,\n            disableBackgroundTransition,\n          });\n\n          this.threshold = 0;\n        }\n      }\n    }\n  };\n\n  render() {\n    const {\n      scrollTop,\n      coloredNav,\n      direction,\n      transitionEnd,\n      currentRoute,\n      mobileMenuIsOpen,\n      damping,\n\n      // sections\n      selectedSectionIndex,\n      sections,\n      sectionDirection,\n      disableBackgroundTransition,\n      lastSectionIndex,\n    } = this.state;\n    const { children, news, titles } = this.props;\n\n    return (\n      <ScrollContext.Provider\n        value={{\n          scrollTop,\n          onScrollableRef: this.onScrollableRef,\n          coloredNav,\n          onEnter: this.onEnter,\n          onExited: this.onExited,\n          direction,\n          onNavLinkClick: this.onNavLinkClick,\n          transitionEnd,\n          currentRoute,\n          mobileMenuIsOpen,\n          toggleMobileMenu: this.toggleMobileMenu,\n\n          // sections\n          news,\n          titles,\n          onLeftSideSectionRef: this.onLeftSideSectionRef,\n          onSectionChange: this.onSectionChange,\n          selectedSectionIndex,\n          sections,\n          sectionDirection,\n          disableBackgroundTransition,\n          lastSectionIndex,\n        }}\n      >\n        <ImagesDownloadListener images={backgrounds} />\n        <Swiper\n          className={styles.swiper}\n          onSwiping={this.onSwiping}\n          onSwiped={this.onSwiped}\n          preventDefaultTouchmoveEvent={true}\n        >\n          <ScrollBar\n            ref={this.onScrollBarRef}\n            damping={damping}\n            plugins={{\n              disableScrollByDirection: {\n                direction: {\n                  x: true,\n                  y:\n                    mobileMenuIsOpen ||\n                    (currentRoute && !currentRoute.scrollable) ||\n                    !transitionEnd,\n                },\n              },\n            }}\n            onScroll={this.onScroll}\n            onWheel={this.onWheel}\n          >\n            {children}\n          </ScrollBar>\n        </Swiper>\n      </ScrollContext.Provider>\n    );\n  }\n}\n\nexport const MainLayoutProvider = ({ children, ...parentProps }) => (\n  <Location>\n    {props => (\n      <MainLayoutProviderComponent {...parentProps} {...props}>\n        {children}\n      </MainLayoutProviderComponent>\n    )}\n  </Location>\n);\n\nexport const MainLayoutConsumer = ScrollContext.Consumer;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAyEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;AACA;AAlFA;AAoFA;AACA;AACA;AAFA;AAIA;AACA;AAzFA;AA0FA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAjGA;AAkGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAHA;AAKA;AACA;AAAA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAGA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AAxKA;AAyKA;AACA;AAEA;AACA;AACA;AAFA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AA5LA;AA8LA;AADA;AAAA;AAKA;AACA;AAEA;AACA;AACA;AAvMA;AAwMA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AA1NA;AA4NA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAnPA;AAoPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxQA;AA0QA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAjRA;AAkRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AACA;AAEA;AACA;AAvTA;AAyTA;AACA;AACA;AACA;AACA;AA7TA;AA+TA;AACA;AACA;AACA;AACA;AAnUA;AAqUA;AACA;AACA;AACA;AACA;AAzUA;AA0UA;AACA;AAAA;AACA;AADA;AAAA;AADA;AACA;AA3UA;AA+UA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AADA;AAIA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AACA;AA9VA;AA+VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAGA;AACA;AAAA;AACA;AAIA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AA5YA;AA8YA;AACA;AACA;AAhZA;AAiZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AAxbA;AA0bA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAhcA;AAicA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAvgBA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AANA;AAAA;AACA;AAWA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAjBA;AA1BA;AA6CA;AACA;AA/CA;AACA;AADA;AAwDA;AACA;AACA;AACA;AACA;AA5DA;AA8DA;AACA;AACA;AACA;AAjEA;AAkEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAzEA;AA2gBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;AADA;AA0BA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AADA;AAWA;AACA;AAfA;AAsBA;AACA;AAvlBA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAylBA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AAFA;AAUA;;;;;;;;;;AArmBA;AAEA;AAylBA;AAUA;;;;;;;;;;;;;A","sourceRoot":""}